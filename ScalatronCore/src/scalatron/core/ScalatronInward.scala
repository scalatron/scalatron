package scalatron.core

import akka.actor.ActorSystem

import scala.concurrent.ExecutionContext


/** This is the "inward" API that Scalatron exposes towards the game plug-ins it loads.
  * It is distinct from the "outward" API that Scalatron exposes towards the main function.
  */
trait ScalatronInward extends Scalatron
{
    // ... everything in trait Scalatron, plus:

    //------------------------------------------------------------------------------------------------------------------
    // configuration information
    //------------------------------------------------------------------------------------------------------------------

    /** @return true if Scalatron is running in "secure" mode and bot plug-ins should be isolated and constrained. */
    def secureMode: Boolean

    /** @return true if Scalatron is running in "verbose" mode and debug information may be logged to the console. */
    def verbose: Boolean

    /** @return map containing command line arguments passed to the Scalatron server at startup. */
    def argMap: Map[String, String]



    //------------------------------------------------------------------------------------------------------------------
    // core resources
    //------------------------------------------------------------------------------------------------------------------

    /** @return reference to the actor system to use for trusted processing. */
    def actorSystem: ActorSystem

    /** @return reference to the execution context to use for untrusted processing. */
    def executionContextForUntrustedCode: ExecutionContext

    /** Returns a collection of fresh entity controllers that can be used to control entities in a game for the
      * duration of one game round. The collection is generated by incrementally scanning the plug-in directory and
      * (re-)loading any changed or new plug-ins, then extracting their control function factories, and lastly
      * invoking all of the control function factories to obtain the control function instances, which are then
      * wrapped and returned as entity controller instances.
      * @return a collection of freshly instantiated entity controllers. */
    def freshEntityControllers : Iterable[EntityController]



    //------------------------------------------------------------------------------------------------------------------
    // callbacks
    //------------------------------------------------------------------------------------------------------------------

    /** The tournament loop should invoke this callback at the end of each simulation step.
      * This will record the state and make it accessible via the "outward" API, e.g. to remote requesters via the web.
      */
    def postStepCallback(mostRecentState: Simulation.UntypedState): Unit

    /** The tournament loop should invoke this callback at the end of each game round.
      * This will record the final state and the game result and make it accessible via the "outward" API,
      * e.g. to remote requesters via the web.
      */
    def postRoundCallback(finalState: Simulation.UntypedState, result: TournamentRoundResult): Unit
}
